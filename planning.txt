30th of October, 2023

We're going to review our text library. Last time we were able to make something that was useable, and achieved most of the goals we set out for. But The pagination at the end was messy, and I seriously lost track of how things worked under the hood. Also I got confused about how to handle different types of effects. I'm confident the linked list system could accomodate almost any effect. I remember rotation being kind of weird, but I'll come back to that one.

Let me get a few thoughts down first. I remember the jitter effect being problematic. That's the one were random characters would jump out of position for a few frames. This one is tricky because it affects different characters at different times. I believe we can review and make our system that affects the linked list more solid. We should focus on making it easy to manipulate the linked list first before remaking text parsing.

We also need to take pagination into account sooner.

We should also consider using the same logic we're considering for the jitter effect for typing. In-fact "typing" could actually be an effect just like any other. I suppose they'd need to be slightly different so the user can affect typing state at any point, but we'll get to that. So in summary:

Review linked list system so effects can easily be made for it.
Ensure pagination is considered for all steps.
Consider making typing an "effect" just like all other effects.

Perhaps for grouping effects, we should ask the user to supply a "name" for the effect. This way our normal closing tag of <> would apply to everything except named effects. Here's an example I'm thinking of:

"Hello world. <jitter-myeffectname:1,2,3>Everything shakes today.<myeffectname> But I feel <wave> solid<>."


2nd of November, 2023

Something that feels wrong is the upward and circular references that exist in the current system. A character array should contain references to characters. But characters have references to drawables. And drawables have references to the same character array that references the characters. I wonder if there's a way to disconnect these references so lower level building blocks aren't aware of each other. I do know why we did this in the first place. It was so that all characters were always aware of what drawable was drawing them, and so drawables could reference the original styles based on the character array. Although this system worked, it doesn't feel right. Let's see if we can't think of a way to remove circular references.


21st of November, 2023

I found myself wishing I could use this library recently, for a typing game. I wanted to be able to set the color of text mid-way. Green at the start and red at the end. We should definitely rework this library a bit so it's easy to do that. And in that case, we wouldn't want to use in-text tags. We'd want something like:

text_set_color(text, color, index_start, index_end);

I have some vague memory of trying to design it like this originally. And design the text typing and animation effects to use these functions.

Yes, on looking it over it looks like that's exactly how we designed it. However I left all the style setting functions internal. Also, it's clear that it's in the styleable text that pagination should occur. If we reflect on our original thoughts, the alterable values of any text are:

font
color
alpha
scale_x
scale_y
mod_x
mod_y
angle
sprite (now quite a style but matters)

And of those: font, scale_x/y, and sprite change how text could actually be positioned. So anytime we change one of those, we need to recalculate line breaks.

We're going to continue using our concept of drawables, items that exist in a linked list that contain information about how to draw text. And our animations/styles will modify these drawables.

Something to note is that when we modify any of these styles, we'll have to recalculate drawables. In our original design we had an array of characters, each containing a default style, from which drawables were calculated. And animations would update drawables after calculated from styles. 

I was thinking to myself "Why even have the character array? Can't we just have drawables modified on the fly?" But I'm pretty sure we ran into situations where we needed to "reset" drawables. But how do you know what to reset the styles to? We need some sort of anchor. This is also a key difference between how animations will work and regular styles. Actually, let's quickly check the render function for our text. There was something important about the order of when we cut and merge drawables. Ah, I think it was as simple as merging drawables, then splitting them, then updating the styles on those drawables. The draw function is this:

loop over drawables and reset styles for each
loop over animations and merge drawables
remove finished animations
loop over animations and split drawables
loop over animations and update drawables

We'll remember this for the future.

So the logic of handling animations makes sense to me. And our model of style, character, and drawable mostly makes sense too. Earlier we discussed removing the circular reference between characters and drawables. I think we can accomplish this by making characters store a reference to drawables, and drawables do not store a reference to character. And the functions for splitting and merging drawables will exist outside of the drawable model.

So, let's review how we could redo the initial text logic to include pagination. Actually this might be very simple. First recall that we'll execute this logic whenever a space altering style changes somewhere. And these changes are applied to the character array. Also recall we keep track of what line a character is on with a line_index field in the character. So to determine line breaks, we simply assign this incrementing number to each character. Once we've done this, we can determine the height of lines by finding the highest character in each line. Now that we have that information we could easily determine which lines should be on which pages based on the height limitation given by the user. 

Perhaps we could assign pages to characters the same way we assign lines. With an index value. And the text class could store the page to display with a basic variable as well. When it comes to drawing, we can know which drawable to start with by finding the first character of the current page, and using whatever drawable it points to. Luckily because of our concept of splitting and merging, drawables will never overlap with the next page. So we could just draw drawables until we find a drawable whos character isn't the current page (or we find the last drawable). Actually it occured to me we may not even need the linked list concept anymore if the character array is going to reference drawables.

This system makes sense to me. Let's summarize:

New verison will retain models of styles, characters, and drawables. Characters contain a line and page index. The text class on creation will determine the x/y position, line index, and page index of every character. Then, drawables will be generated from the characters. The text is now complete and ready to be rendered.

Note: during parsing we might also want to store information about start and ends of lines excluding spaces. Later this will help us draw text with different alignments.

Once text is created, the user will have access to functions which change the styles of the characters. For starters, since we'll already have logic which generates characters from drawables, we can simply run that again. But for performance we may want to only run the entire logic again for styles which change size of characters.

Finally we'll need to create draw functions for the text class which only draw the current page. 

Once we create this we could experiment with a crude typing system that just sets the alpha of text. And possibly a few other animations. The new system makes sense to me. I think we can try implementing this next time.


25th of November, 2023

It occured to me we may not need line index. We could just use the y position of characters.


27th of November, 2023

Still working through line break and pagination. Working slowly, and was distracted by Thanksgiving.
Random thought I had about text rotation:
We need to offset the draw x/y of text in order for the rotation to appear around the center. But since we'd want to be able to set offset and rotation separately, I think it makes sense if the rotation/angle setting had its own offset values. Furthermore, it occured to me that each individual character requires a different offset if drawn individually. I think we should store this information in the characters. But if the characters all end up with different offset values, our original logic for determining if a drawable can be merged will flag each character with rotation data as separate. This feels inefficient. Further more... how do we determine the center if there's a line break? I'm starting to think text rotation might not be worth the effort. Maybe we just allow for individual characters to rotate around their center.

Just managed to get basic line breaks and character positions. I was thinking about whether or not I wanted a separate style class to be held by both characters and drawables. However I realized that since we're containing everything within the text class, and characters will reference drawables, why even give the drawables a style? Actually, the drawable just needs to be an index range. We know that drawables will refer to index ranges, and the characters in those index ranges already contain those styles. So when it comes to drawing all we really need from the drawable is the start index, and the characters to draw, because we can get the styles using the start index in the character array. The end index really is just a way to refer to the next drawable. 

So let's start adding drawables, but recognize they just need index range and text content.

Actually, no, let's make sure we've got pagination first. That was the feature that seriously threw us off at the end last time.

This is giving us trouble again. Let's review some logic. Our current system only tracks where the x/y position of characters should be. For pagination we need lines to start on new pages if their height would bring the page height beyond the given user height limit. However we will always allow one line per page no matter the height limit. So if the first line of text is 60px high, but our height limit is 50px, we still have that first line of text on the first page. 

It would be most elegant to figure out how to assign pages to characters as we're parsing through them for line breaks. But this won't work, and that's because we can't know the height of a line until we've parsed through all characters in a line. So if the very last character ends up being to high, and makes the line too big, we have to assign a new page value to that entire line. We may have to do something similar to our older system where we keep track of line heights, determine pages for each line, then go back over the characters and reassign page index to each character. 
